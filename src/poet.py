"""
Generates text in the style of a poet from a provided seed.

To create more variety in the results without altering the engine's parameters,
a random selection of poems are taken from a corpus and passed to OpenAI whenever
generate() is called. This also reduces costs.
"""
import openai
import os
import json
import random
from basho.src.poem import Poem
from basho.src.book import Book


class Poet(object):
    """
    A Poet that can write poems in a given style using OpenAI's api.

    OpenAI can be financially expensive, so individual examples used in the corpus should be kept short. However,
    since the generate() method samples examples from the corpus, the corpus itself can
    be as large as needed. OpenAI doesn't seem to need too many examples (in some cases,
    more examples seem to return worse results). Default OpenAI parameter values are hardcoded here,
    since these have produced the best results so far.
    """

    openai.api_key = os.getenv("OPENAI_API_KEY")

    def __init__(self, header, corpus, engine="davinci", temp=0.75,
                 max_len=64, tp=0.7, freq_pen=0.6, pres_pen=0.6, file=True):
        """
        Initializer for the Poet class.

        This initializes a Poet.

        Parameter header: A short description of what the Poet will write.
        Precondition: header is a string (preferably a short one, such as "Writes
        haikus in the style of Basho"
        Parameter corpus: A json file composed of (label, poem) pairs, where poems have
        lines separated by "/".
        Precondition: corpus is a valid json file.
        Parameter engine: The OpenAI engine to use to generate the poem.
        Precondition: engine is a valid engine.
        Parameter temp: temperature parameter for OpenAI
        Precondition: temp is a float between 0.0 and 1.0.
        Parameter max_len: The maximum number of tokens to be generated by OpenAI.
        Precondition: max_len is a float (preferably a small one, to reduce costs).
        Paramter tp: tp is the top_p paramter for OpenAI.
        Precondition: tp is a float between 0.0 and 1.0.
        Paramter freq_pen: freq_pen is the frequency_penalty parameter for OpenAI.
        Precondition: freq_pen is a float between 0.0 and 1.0.
        Paramter pres_pen: pres_pen is the presence_penalty paramter for OpenAI.
        Precondition: pres_pen is a float between 0.0 and 1.0.
        """
        self.header = header + "\n\n"
        self.engine = engine
        self.temp = temp
        self.max_len = max_len
        self.tp = tp
        self.freq_pen = freq_pen
        self.pres_pen = pres_pen
        with open(corpus) as json_file:
            self.corpus = json.load(json_file)

    @classmethod
    def from_book(cls, header, path, book, keep=True):
        """
        If two Poems have the same label, only the first in the Book will be
        used!

        Parameter keep: Whether to keep the original Book as an attribute of the
        Poet.
        """
        poems = {}
        for label in book:
            poem = book.pages[label]
            text = poem.text
            poems.update({label: text})
        json_poems = json.dumps(poems)
        with open(path, "w") as file:
            file.write(json_poems)
        if keep:
            new_poet = cls(header, path)
            new_poet.book = book
            return new_poet
        return cls(header, path)

    def generate(self, size, seed, verbose=False):
        """
        Returns a poem (with the poem's lines separated by "/") as a string.

        This method will generate OpenAI Completion output. The poem has an leading space
        and ends in "\n", which is a little annoying, but easily remedied later.

        Parameter size: The number of examples to be sampled from the corpus.
        Precondition: size is an int less than the size of the corpus.
        Parameter seed: a word used to generate the poem.
        Precondition: seed is a (one or two word) string.
        """
        p = self.build_prompt(size, self.corpus, self.header)
        response = openai.Completion.create(
           engine=self.engine,
           prompt=p + "Seed: " + seed + "\nPoem:",
           temperature=self.temp,
           max_tokens=self.max_len,
           top_p=self.tp,
           frequency_penalty=self.freq_pen,
           presence_penalty=self.pres_pen,
           stop=["###"]
         )
        if verbose:
            return p + "\nSeed: " + seed + "\nGenerated poem: \n" + \
                   response.choices[0]["text"]
        return response.choices[0]["text"]

    def generate_poem(self, size, seed):
        """
        """
        text = self.generate(size, seed)
        return Poem(text, label=seed, author="OpenAI")

    def generate_book(self, size, seed, author="NaN"):
        """
        """
        try:
            keys = self.random_keys(size, self.book)
            prompt_poems = {}
            for key in keys:
                prompt_poems.update({key: self.book[key]})
        except NameError:
            keys = self.random_keys(size, self.corpus)
            prompt_poems = {}
            for key in keys:
                p = Poem(self.corpus[key], author=author)
                prompt_poems.update({key: p})
        p = self.header
        for key, poem in prompt_poems.items():
            p += "Seed: {}\nPoem: {}\n###\n".format(key, poem.text)
        ai = openai.Completion.create(
           engine=self.engine,
           prompt=p + "Seed: " + seed + "\nPoem:",
           temperature=self.temp,
           max_tokens=self.max_len,
           top_p=self.tp,
           frequency_penalty=self.freq_pen,
           presence_penalty=self.pres_pen,
           stop=["###"]
         )
        prompt_poems.update({"%" + seed: Poem(ai.choices[0]["text"],
                                        author="OpenAI", label="%" + seed,
                                        delimiter="/")})
        return Book(prompt_poems)

    @staticmethod
    def random_keys(size, dict):
        """
        Returns a list of pseudorandom keys from a provided dictionary of a given
        number of labeled examples of poems.

        Parameter size: the number of examples to be sampled from the corpus.
        Precondition: size is an int, where 0 <= size < corpus.size().
        Parameter dict: the corpus to be sampled.
        Precondition: dict is a dictionary of labeled examples which are
        short in length, to reduce financial costs.
        """
        corpus_keys = list(dict.keys())
        sample_keys = []
        while len(sample_keys) < size:
            key_ix = random.randint(0, len(corpus_keys)-1)
            if corpus_keys[key_ix] not in sample_keys:
                sample_keys.append(corpus_keys[key_ix])
        return sample_keys

    def build_prompt(self, size, dict, header):
        """
        Builds a prompt for OpenAI given a corpus of labeled examples.

        Parameter size: the number of examples to be sampled from a given corpus.
        Precondition: size is a positive int < the size of dict.
        Parameter dict: a corpus of labeled examples.
        Precondition: dict is a dictionary composed of (key, value) pairs of examples,
            which are strings (preferably short ones).
        Parameter header: header is a brief description of the poems to be generated.
        Precondition: header is a string (a short one) ending in two trailing "\n".
        """
        sample_keys = self.random_keys(size, dict)
        prompt = header
        for key in sample_keys:
            prompt += "Seed: {}\nPoem: {}\n###\n".format(key, dict[key])
        return prompt
